<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Golang | Slice Deep Learning - Zher</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="zher" /><meta name="description" content=" Go Blog: Go slice internals å­¦ä¹ ç¬”è®°
" /><meta name="keywords" content="zher, blog, tech, essay, life, footprint" />






<meta name="generator" content="Hugo 0.52 with even 4.0.0" />


<link rel="canonical" href="https://zhezh09.github.io/post/tech/code/golang/20181117-slice-deep-learning/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.93844dae.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Golang | Slice Deep Learning" />
<meta property="og:description" content="


Go Blog: Go slice internals å­¦ä¹ ç¬”è®°
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhezh09.github.io/post/tech/code/golang/20181117-slice-deep-learning/" /><meta property="article:published_time" content="2018-11-17T14:00:24&#43;08:00"/>
<meta property="article:modified_time" content="2018-11-21T14:00:24&#43;00:00"/>

<meta itemprop="name" content="Golang | Slice Deep Learning">
<meta itemprop="description" content="


Go Blog: Go slice internals å­¦ä¹ ç¬”è®°
">


<meta itemprop="datePublished" content="2018-11-17T14:00:24&#43;08:00" />
<meta itemprop="dateModified" content="2018-11-21T14:00:24&#43;00:00" />
<meta itemprop="wordCount" content="3304">



<meta itemprop="keywords" content="golang," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang | Slice Deep Learning"/>
<meta name="twitter:description" content="


Go Blog: Go slice internals å­¦ä¹ ç¬”è®°
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Zher</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/categories/footprint/">
        <li class="mobile-menu-item">FootPrint</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Zher</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/footprint/">FootPrint</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Golang | Slice Deep Learning</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-17 </span>
        <div class="post-category">
            <a href="/categories/tech/"> tech </a>
            </div>
          <span class="more-meta"> 3304 words </span>
          <span class="more-meta"> 7 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#slice-internals">Slice internals</a></li>
<li><a href="#growing-slices-the-copy-and-append-functions">Growing slices(the copy and append functions)</a></li>
<li><a href="#a-possible-gotcha">A possible &ldquo;gotcha&rdquo;</a></li>
<li><a href="#further-reading">Further Reading</a>
<ul>
<li><a href="#effective-go-slices">Effective Go | Slices</a></li>
</ul></li>
<li><a href="#see-also">See Also</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <!-- æ‘˜è¦ -->

<blockquote>
<p><a href="https://blog.golang.org/go-slices-usage-and-internals">Go Blog: Go slice internals å­¦ä¹ ç¬”è®°</a></p>
</blockquote>

<h1 id="slice-internals">Slice internals</h1>

<p>A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment).</p>

<p>ä¸€ä¸ªåˆ‡ç‰‡å°±æ˜¯ä¸€ä¸ªæ•°ç»„ç‰‡æ®µçš„æè¿°ç¬¦ã€‚å®ƒ(åˆ‡ç‰‡)åŒ…å«äº†ä¸€ä¸ªæŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆï¼Œç‰‡æ®µçš„é•¿åº¦å’Œå®¹é‡(æŒ‡è¿™ä¸ªç‰‡æ®µçš„æœ€å¤§é•¿åº¦)</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-struct.png" alt="" /></p>

<p>Our variable s, created earlier by make([]byte, 5), is structured like this:</p>

<p>å˜é‡ s, å…ˆå‰é€šè¿‡ <code>make([]byte, 5)</code> åˆ›å»ºï¼Œç»“æ„å¦‚ä¸‹ï¼š</p>

<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-1.png" alt="" /></p>

<p>The length is the number of elements referred to by the slice. The capacity is the number of elements in the underlying array (beginning at the element referred to by the slice pointer). The distinction between length and capacity will be made clear as we walk through the next few examples.</p>

<p>é•¿åº¦å°±æ˜¯åˆ‡ç‰‡å¼•ç”¨çš„å…ƒç´ æ•°é‡ã€‚å®¹é‡å°±æ˜¯åº•å±‚æ•°ç»„(ä»åˆ‡ç‰‡æŒ‡é’ˆå¼•ç”¨çš„å…ƒç´ å¼€å§‹ï¼Œåˆ°æ•´ä¸ªæ•°ç»„æœ«å°¾)çš„å…ƒç´ æ•°é‡ã€‚ä¸¾ä¾‹è¯´æ˜ï¼š</p>

<p>As we slice s, observe the changes in the slice data structure and their relation to the underlying array:</p>

<p>å½“æˆ‘ä»¬åˆ‡å‰² s æ—¶ï¼Œè§‚å¯Ÿåˆ‡ç‰‡ s çš„æ•°æ®ç»“æ„ä»¥åŠå®ƒä»¬å’Œåº•å±‚æ•°ç»„é—´å…³ç³»çš„å˜åŒ–ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span></code></pre></td></tr></table>
</div>
</div>
<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-2.png" alt="" /></p>

<p>Slicing does not copy the slice&rsquo;s data. It creates a new slice value that points to the original array. This makes slice operations as efficient as manipulating array indices. Therefore, modifying the elements (not the slice itself) of a re-slice modifies the elements of the original slice:</p>

<p>åˆ†å‰²å¹¶æ²¡æœ‰æ‹·è´åˆ‡ç‰‡çš„æ•°æ®ã€‚å®ƒä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ sliceï¼Œæ–°çš„ slice è¿˜æ˜¯æŒ‡å‘äº†åŸæ¥çš„æ•°ç»„ã€‚è¿™ä½¿å¾— <code>åˆ‡ç‰‡æ“ä½œ</code> å°±å’Œæ“ä½œæ•°ç»„ç´¢å¼•ä¸€æ ·é«˜æ•ˆã€‚å› æ­¤ï¼Œä¿®æ”¹ä¸€ä¸ªé‡æ–°åˆ†ç‰‡åçš„åˆ‡ç‰‡çš„å…ƒç´ (ä¸æ˜¯åˆ‡ç‰‡æœ¬èº«)ï¼Œä¹Ÿå°±æ˜¯åœ¨ä¿®æ”¹åŸå§‹åˆ‡ç‰‡çš„å…ƒç´ ï¼Œçœ‹ä¾‹å­ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">d</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">}</span>
<span class="nx">e</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> 
<span class="c1">// e == []byte{&#39;a&#39;, &#39;d&#39;}
</span><span class="c1"></span><span class="nx">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;m&#39;</span>
<span class="c1">// e == []byte{&#39;a&#39;, &#39;m&#39;}
</span><span class="c1"></span><span class="o">//</span> <span class="nx">d</span> <span class="o">==</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>Note: e æ˜¯é€šè¿‡åœ¨åˆ‡ç‰‡ d ä¸Šæ‰§è¡Œ <code>åˆ‡ç‰‡æ“ä½œ[start:end]</code> è€Œå¾—åˆ°çš„æ–°åˆ‡ç‰‡ï¼Œä½†ä¿®æ”¹ e çš„æŸä¸ªå…ƒç´ ä¹Ÿä¼šä¿®æ”¹åŸå§‹åˆ‡ç‰‡çš„å…ƒç´ çš„</p>
</blockquote>

<p>Earlier we sliced s to a length shorter than its capacity. We can grow s to its capacity by slicing it again:</p>

<p>æ—©å…ˆçš„æ—¶å€™ï¼Œæˆ‘ä»¬æŠŠ s åˆ‡å‰²åˆ°äº†ä¸€ä¸ªæ¯”å®ƒçš„å®¹é‡è¿˜å°çš„é•¿åº¦. æˆ‘ä»¬å¯ä»¥é‡æ–°åˆ‡ç‰‡æŠŠå®ƒçš„é•¿åº¦æ‰©å±•åˆ°å’Œå®¹é‡ä¸€æ ·ã€‚å®ä¾‹å¦‚ä¸‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Earlier code is:
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

<span class="c1">// Now 
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span></code></pre></td></tr></table>
</div>
</div>
<p><img src="https://blog.golang.org/go-slices-usage-and-internals_slice-3.png" alt="" /></p>

<p>A slice cannot be grown beyond its capacity. Attempting to do so will cause a runtime panic, just as when indexing outside the bounds of a slice or array. Similarly, slices cannot be re-sliced below zero to access earlier elements in the array.</p>

<p>ä¸€ä¸ªåˆ‡ç‰‡ä¸èƒ½æ‰©å±•çš„è¶…è¿‡å…¶å®¹é‡ã€‚å¦‚æœéè¦è¿™ä¹ˆåšçš„è¯ï¼Œå°±ä¼šå¯¼è‡´ä¸€ä¸ªè¿è¡Œæ—¶ panicï¼Œå› ä¸ºç´¢å¼•è¶Šç•Œäº†ã€‚ç±»ä¼¼åœ°ï¼Œåˆ‡ç‰‡ä¸èƒ½åœ¨é›¶ä»¥ä¸‹é‡æ–°åˆ‡ç‰‡ä»¥è®¿é—®æ•°ç»„ä¸­çš„æ—©æœŸå…ƒç´ (å³ï¼šslice æŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆåªèƒ½å‘åç§»åŠ¨, ä¸èƒ½å‘å‰ç§»åŠ¨)ã€‚</p>

<h1 id="growing-slices-the-copy-and-append-functions">Growing slices(the copy and append functions)</h1>

<p>To increase the capacity of a slice one must create a new, larger slice and copy the contents of the original slice into it. This technique is how dynamic array implementations from other languages work behind the scenes. The next example doubles the capacity of s by making a new slice, t, copying the contents of s into t, and then assigning the slice value t to s:</p>

<p>è¦å¢åŠ ä¸€ä¸ªåˆ‡ç‰‡çš„å®¹é‡ï¼Œå°±å¿…é¡»åˆ›å»ºä¸€ä¸ªæ–°çš„ï¼Œæ›´å¤§çš„åˆ‡ç‰‡å¹¶ä¸”æŠŠåŸå§‹åˆ‡ç‰‡çš„å†…å®¹æ‹·è´åˆ°æ–°å»ºç«‹çš„åˆ‡ç‰‡ä¸­å»ã€‚è¿™ç§æŠ€æœ¯å°±æ˜¯å…¶ä»–è¯­è¨€çš„åŠ¨æ€æ•°ç»„çš„èƒŒåå®ç°ã€‚ä¸‹é¢ä¾‹å­é€šè¿‡åˆ›å»ºä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ tï¼Œå¹¶å°† s çš„å†…å®¹å¤åˆ¶åˆ° tï¼Œç„¶åå°†åˆ‡ç‰‡å€¼ t åˆ†é…ç»™ s æ¥ä½¿ s çš„å®¹é‡åŠ å€ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// +1 in case cap(s) == 0
</span><span class="c1"></span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">s</span> <span class="p">=</span> <span class="nx">t</span></code></pre></td></tr></table>
</div>
</div>
<p>The looping piece of this common operation is made easier by the built-in copy function. As the name suggests, copy copies data from a source slice to a destination slice. It returns the number of elements copied.</p>

<p>ä¸Šé¢è¿™ç§è‰è›¹çš„å¾ªç¯æ“ä½œå¯ä»¥ä½¿ç”¨å†…å»ºçš„ <code>copy</code> å‡½æ•°æ›´åŠ è½»æ¾çš„å®Œæˆã€‚é¡¾åæ€ä¹‰ &hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span></code></pre></td></tr></table>
</div>
</div>
<p>The copy function supports copying between slices of different lengths (it will copy only up to the smaller number of elements). In addition, copy can handle source and destination slices that share the same underlying array, handling overlapping slices correctly.</p>

<p><code>copy</code> å‡½æ•°æ”¯æŒåœ¨ä¸åŒé•¿åº¦çš„åˆ‡ç‰‡é—´è¿›è¡Œæ‹·è´(ä»…æ”¯æŒæ‹·è´å°äºç­‰äºåŸsliceé•¿åº¦çš„æ•°æ®)ã€‚å¦å¤–ï¼Œæ‹·è´å‡½æ•°å¯ä»¥å¤„ç†å…±äº«äº†åº•å±‚æ•°ç»„çš„åŸåˆ‡ç‰‡å’Œç›®çš„åˆ‡ç‰‡ï¼Œå¹¶ä¸”ä¼šå¾ˆå¥½çš„å¤„ç†é‡å çš„éƒ¨åˆ†.</p>

<p>Using copy, we can simplify the code snippet above:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">copy</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nx">t</span></code></pre></td></tr></table>
</div>
</div>
<p>A common operation is to append data to the end of a slice. This function appends byte elements to a slice of bytes, growing the slice if necessary, and returns the updated slice value:</p>

<p>ä¸€ä¸ªç»å¸¸ä½¿ç”¨çš„æ“ä½œæ˜¯å‘sliceæœ«å°¾åŠ æ•°æ®.ä¸‹é¢çš„å‡½æ•°å‘ byte slice é‡Œæ·»åŠ å­—èŠ‚æ•°æ®, å¦‚æœæœ‰å¿…è¦, ä¼šè‡ªåŠ¨å¢åŠ å®¹é‡, è¿”å›æ›´æ–°åçš„ slice.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AppendByte</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">data</span> <span class="o">...</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">m</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if necessary, reallocate
</span><span class="c1"></span>        <span class="c1">// allocate double what&#39;s needed, for future growth.
</span><span class="c1"></span>        <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
    <span class="p">}</span>
    <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span>

    <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">m</span><span class="p">:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>One could use AppendByte like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">p</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">p</span> <span class="p">=</span> <span class="nf">AppendByte</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>

<span class="o">//</span> <span class="nx">p</span> <span class="o">==</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Functions like AppendByte are useful because they offer complete control over the way the slice is grown. Depending on the characteristics of the program, it may be desirable to allocate in smaller or larger chunks, or to put a ceiling on the size of a reallocation.</p>

<p>åƒ AppendByte è¿™æ ·çš„å‡½æ•°éå¸¸æœ‰ç”¨. å› ä¸ºå®ƒæ›´èƒ½å¯¹ slice çš„æ‰©å®¹æœ‰ç€å®Œæ•´çš„æ§åˆ¶ã€‚æ ¹æ®å…·ä½“çš„é¡¹ç›®, å¯èƒ½éœ€è¦åˆ†é…æ›´å°æˆ–è€…æ›´å¤§çš„ç©ºé—´æ¥è·å¾—æœ€ä½³æ•ˆæœ. æˆ–è€…æ˜¯å¯¹æ‰©å®¹çš„ä¸Šé™ç»™å‡ºé™åˆ¶ã€‚</p>

<p>But most programs don&rsquo;t need complete control, so Go provides a built-in append function that&rsquo;s good for most purposes; it has the signature</p>

<p>ä½†æ˜¯å¤šæ•°çš„é¡¹ç›®ä¸éœ€è¦å®Œæ•´çš„æ§åˆ¶. æ‰€ä»¥ Go æä¾›äº† append å‡½æ•°.å®ƒèƒ½æ»¡è¶³å¤§å¤šæ•°çš„éœ€æ±‚. ç­¾åå¦‚ä¸‹:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span></code></pre></td></tr></table>
</div>
</div>
<p>The append function appends the elements x to the end of the slice s, and grows the slice if a greater capacity is needed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">// a == []int{0}
</span><span class="c1"></span><span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">//</span> <span class="nx">a</span> <span class="o">==</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>To append one slice to another, use &hellip; to expand the second argument to a list of arguments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;John&#34;</span><span class="p">,</span> <span class="s">&#34;Paul&#34;</span><span class="p">}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;George&#34;</span><span class="p">,</span> <span class="s">&#34;Ringo&#34;</span><span class="p">,</span> <span class="s">&#34;Pete&#34;</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="o">...</span><span class="p">)</span> <span class="c1">// equivalent to &#34;append(a, b[0], b[1], b[2])&#34;
</span><span class="c1"></span><span class="o">//</span> <span class="nx">a</span> <span class="o">==</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;John&#34;</span><span class="p">,</span> <span class="s">&#34;Paul&#34;</span><span class="p">,</span> <span class="s">&#34;George&#34;</span><span class="p">,</span> <span class="s">&#34;Ringo&#34;</span><span class="p">,</span> <span class="s">&#34;Pete&#34;</span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Since the zero value of a slice (nil) acts like a zero-length slice, you can declare a slice variable and then append to it in a loop:</p>

<p>å› ä¸ºä¸€ä¸ªåˆ‡ç‰‡çš„é›¶å€¼(nil) å°±å¥½æ¯”æ˜¯é•¿åº¦ä¸º 0 çš„åˆ‡ç‰‡ï¼Œæ‰€ä»¥ä½ å¯ä»¥å£°æ˜ä¸€ä¸ªç©ºçš„ slice å˜é‡,å¹¶å‘é‡Œé¢æŒ¨ä¸ªæ·»åŠ æ•°æ®.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Filter returns a new slice holding only
</span><span class="c1">// the elements of s that satisfy f()
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Filter</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">p</span> <span class="p">[]</span><span class="kt">int</span> <span class="c1">// == nil
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="a-possible-gotcha">A possible &ldquo;gotcha&rdquo;</h1>

<p>å¯èƒ½çš„ &ldquo;é™·é˜±&rdquo;</p>

<p>As mentioned earlier, re-slicing a slice doesn&rsquo;t make a copy of the underlying array. The full array will be kept in memory until it is no longer referenced. Occasionally this can cause the program to hold all the data in memory when only a small piece of it is needed.</p>

<p>For example, this FindDigits function loads a file into memory and searches it for the first group of consecutive numeric digits, returning them as a new slice.</p>

<p>å°±åƒå…ˆå‰æåˆ°çš„ï¼Œ<code>åˆ‡ç‰‡æ“ä½œ</code> å¹¶ä¸ä¼šåˆ›å»ºåº•å±‚æ•°ç»„çš„æ‹·è´ã€‚æ•´ä¸ªæ•°ç»„éƒ½å°†è¢«ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œç›´åˆ°å®ƒä¸å†è¢«å¼•ç”¨ã€‚æœ‰æ—¶å€™å¯èƒ½ä¼šå› ä¸ºä¸€ä¸ªå°çš„å†…å­˜å¼•ç”¨å¯¼è‡´ä¿å­˜æ‰€æœ‰çš„æ•°æ®ã€‚</p>

<p>ä¾‹å¦‚ï¼Œ<code>FindDigits</code> å‡½æ•°åŠ è½½æ•´ä¸ªæ–‡ä»¶åˆ°å†…å­˜ï¼Œç„¶åæœç´¢ç¬¬ä¸€ä¸ªè¿ç»­çš„æ•°å­—ï¼Œæœ€åç»“æœä»¥åˆ‡ç‰‡æ–¹å¼è¿”å›ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">digitRegexp</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;[0-9]+&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">FindDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>This code behaves as advertised, but the returned []byte points into an array containing the entire file. Since the slice references the original array, as long as the slice is kept around the garbage collector can&rsquo;t release the array; the few useful bytes of the file keep the entire contents in memory.</p>

<p>è¿™æ®µä»£ç çš„è¡Œä¸ºå’Œæè¿°ç±»ä¼¼ï¼Œè¿”å›çš„ []byte æŒ‡å‘ä¿å­˜æ•´ä¸ªæ–‡ä»¶çš„æ•°ç»„ã€‚å› ä¸ºåˆ‡ç‰‡å¼•ç”¨äº†åŸå§‹çš„æ•°ç»„ï¼Œå¯¼è‡´ GC ä¸èƒ½é‡Šæ”¾æ•°ç»„çš„ç©ºé—´ï¼›åªç”¨åˆ°å°‘æ•°å‡ ä¸ªå­—èŠ‚å´å¯¼è‡´æ•´ä¸ªæ–‡ä»¶çš„å†…å®¹éƒ½ä¸€ç›´ä¿å­˜åœ¨å†…å­˜é‡Œã€‚</p>

<p>To fix this problem one can copy the interesting data to a new slice before returning it:</p>

<p>è¦ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œåœ¨è¿”å›ä¹‹å‰å¯ä»¥å°†æ„Ÿå…´è¶£çš„æ•°æ®å¤åˆ¶åˆ°ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ä¸­ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> 
    <span class="nx">b</span> <span class="p">=</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>ä½¿ç”¨ append å‡½æ•°æ”¹è¿›ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">b</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="further-reading">Further Reading</h1>

<p><a href="https://golang.org/doc/effective_go.html">Effective Go</a> contains an in-depth treatment(æ¢è®¨) of <a href="https://golang.org/doc/effective_go.html#slices">slices</a> and <a href="https://golang.org/doc/effective_go.html#arrays">arrays</a>, and the Go <a href="https://golang.org/doc/go_spec.html">language specification</a> defines <a href="https://golang.org/doc/go_spec.html#Slice_types">slices</a> and their <a href="https://golang.org/doc/go_spec.html#Making_slices_maps_and_channels">associated helper functions</a>.</p>

<h2 id="effective-go-slices">Effective Go | Slices</h2>

<p>Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays.</p>

<p>åˆ‡ç‰‡é€šè¿‡å¯¹æ•°ç»„å°è£…è¿›è¡Œå°è£…ï¼Œæä¾›äº†æ›´åŠ é€šç”¨çš„ï¼Œå¼ºå¤§çš„å’Œæ–¹ä¾¿çš„æ¥å£æ¥åºåˆ—åŒ–æ•°æ®ã€‚é™¤äº†åƒçŸ©é˜µå˜æ¢è¿™ç§æœ‰æ˜ç¡®å”¯ç‹¬éœ€æ±‚çš„æƒ…å†µå¤–ï¼ŒGo ä¸­çš„å¤§éƒ¨åˆ†æ•°ç»„ç¼–ç¨‹éƒ½æ˜¯é€šè¿‡åˆ‡ç‰‡æ¥å®Œæˆçš„ã€‚</p>

<p>Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array(ç±»ä¼¼äºä¼ é€’äº†ä¸€ä¸ªæŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆ). A <code>Read</code> function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the <code>Read</code> method of the File type in package os:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">file</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>The method returns the number of bytes read and an error value, if any(å¦‚æœæœ‰çš„è¯). To read into the first 32 bytes of a larger buffer buf, slice (here used as a verb) the buffer.</p>

<p>è¯¥æ–¹æ³•è¿”å›è¯»å–çš„å­—èŠ‚æ•°å’Œä¸€ä¸ªé”™è¯¯å€¼(è‹¥æœ‰çš„è¯)ã€‚è‹¥è¦ä»æ›´å¤§çš„ç¼“å†²åŒº buf ä¸­è¯»å–å‰ 32 ä¸ªå­—èŠ‚ï¼Œåªéœ€è¦å¯¹å…¶è¿›è¡Œ <code>åˆ‡ç‰‡</code> å³å¯ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span></code></pre></td></tr></table>
</div>
</div>
<p>Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer.</p>

<p>è¿™ç§åˆ‡ç‰‡çš„æ–¹æ³•å¸¸ç”¨ä¸”é«˜æ•ˆã€‚è‹¥ä¸è°ˆæ•ˆç‡ï¼Œä»¥ä¸‹ç‰‡æ®µåŒæ ·èƒ½è¯»å–è¯¥ç¼“å†²åŒºçš„å‰32ä¸ªå­—èŠ‚ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span> 
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// è¯»å–ä¸€ä¸ªå­—èŠ‚
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">nbytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
        <span class="k">break</span>
    <span class="p">}</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="nx">nbytes</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The capacity of a slice, accessible by the built-in function cap, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that len and cap are legal when applied to the nil slice, and return 0.</p>

<p>åœ¨åˆ‡ç‰‡çš„é•¿åº¦æ²¡è¶…è¿‡åº•å±‚æ•°ç»„çš„é™åˆ¶ï¼Œå°±å¯ä»¥æ”¹å˜å®ƒçš„é•¿åº¦ï¼Œåªéœ€è¦å°†å®ƒèµ‹äºˆå…¶è‡ªèº«çš„åˆ‡ç‰‡å³å¯ã€‚åˆ‡ç‰‡çš„ <code>å®¹é‡</code> å¯ä»¥é€šè¿‡å†…å»ºå‡½æ•° cap è·å¾—ï¼Œå®ƒå°†è¿”å›è¿™ä¸ªåˆ‡ç‰‡èƒ½å–åˆ°çš„æœ€å¤§é•¿åº¦ã€‚ä»¥ä¸‹æ˜¯å°†æ•°æ®è¿½åŠ åˆ°åˆ‡ç‰‡çš„å‡½æ•°ã€‚è‹¥æ•°æ®è¶…å‡ºå…¶å®¹é‡ï¼Œåˆ™è¯¥åˆ‡ç‰‡å°†ä¼šé‡æ–°è¢«åˆ†é…ã€‚è¿”å›å€¼å³ä¸ºæ‰€å¾—çš„åˆ‡ç‰‡(æ–°åˆ†é…çš„)ã€‚è¯¥å‡½æ•°ä¸­æ‰€ä½¿ç”¨çš„ len å’Œ cpa åœ¨ <code>nil</code> åˆ‡ç‰‡ä¸Šåº”ç”¨æ—¶æ˜¯åˆæ³•çš„ï¼Œä¼šè¿”å› 0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// é‡æ–°åˆ†é…
</span><span class="c1"></span>        <span class="c1">// ä¸ºäº†åé¢çš„å¢é•¿ï¼Œéœ€åˆ†é…ä¸¤ä»½ã€‚
</span><span class="c1"></span>        <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">(</span><span class="nx">l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
    <span class="p">}</span>
    <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)]</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">data</span> <span class="p">{</span>
        <span class="nx">slice</span><span class="p">[</span><span class="nx">l</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>We must return the slice afterwards because, although Append can modify the elements of slice, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value.</p>

<p>The idea of appending to a slice is so useful it&rsquo;s captured by the append built-in function. To understand that function&rsquo;s design, though, we need a little more information, so we&rsquo;ll return to it later.</p>

<h1 id="see-also">See Also</h1>

<blockquote>
<p>Thanks to the authors ğŸ™‚</p>
</blockquote>

<ul>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals">The Go Blogï¼šGo Slices: usage and internals</a></li>
<li><a href="https://blog.golang.org/slices">The Go Blogï¼šArrays, slices (and strings): The mechanics of &lsquo;append&rsquo;</a></li>
<li><a href="https://golang.org/doc/effective_go.html#slices">Effective Go | Slices</a></li>
<li><a href="https://go-zh.org/doc/effective_go.html#%E5%88%87%E7%89%87">å®æ•ˆGoç¼–ç¨‹ä¸­æ–‡ç¤¾åŒº</a>
<br /></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">zher</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-11-21</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/tech/code/golang/20181121-slice-src-reading/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[è½¬] Golang | Slice æ·±å…¥ç†è§£</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/tech/code/golang/20180913-tutorial-go36-02/">
            <span class="next-text nav-default">ã€Goæ ¸å¿ƒ36è®²ã€| 02-æ•°ç»„ä¸åˆ‡ç‰‡</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2018-11-17 14:00:24 \x2b0800 CST',
        title: 'Golang | Slice Deep Learning',
        clientID: '4357c1dbcf7ef0515c29',
        clientSecret: '1ad00adfd9544bff956529daf898d4b81fed2a9d',
        repo: 'blog-comments',
        owner: 'zhezh09',
        admin: ['zhezh09'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zhezh.boy@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/zher16297365" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.facebook.com/zhe.zh.54" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://plus.google.com/u/0/103084907763171979239" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/zhezh09" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/p/1005053510554731/home?from=page_100505&amp;mod=TAB&amp;is_all=1#place" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/boy-zhe/activities" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.instagram.com/zher09/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="https://zhezh09.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zher</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.ece58db6.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123995495-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
