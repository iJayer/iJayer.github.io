<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on ijayer</title>
    <link>https://ijayer.github.io/tags/golang/</link>
    <description>Recent content in golang on ijayer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 19 Apr 2020 22:20:58 +0800</lastBuildDate>
    
	<atom:link href="https://ijayer.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Empty struct in Go[译]</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20200419_emtpy_struct_in_go/</link>
      <pubDate>Sun, 19 Apr 2020 22:20:58 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20200419_emtpy_struct_in_go/</guid>
      <description>&lt;!-- 摘要 --&gt;

&lt;p&gt;空结构体 &lt;code&gt;empty struct&lt;/code&gt; 也是结构体类型，不过呢它不包含有任何字段。声明定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Q&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So, 一个没有包含任意字段的结构体能干什么用？或者说它的用途是什么呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Simple Scheduling Library (Go) [译]</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20200308_simple_scheduler_lib/</link>
      <pubDate>Sun, 08 Mar 2020 21:58:50 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20200308_simple_scheduler_lib/</guid>
      <description>&lt;!-- 摘要 --&gt;

&lt;p&gt;现在的应用程序或多或少都有这样得需求，既 &lt;code&gt;在给定的某段时间重复执行一段代码&lt;/code&gt;。这段代码可能是从其他数据源获取数据进行解析，亦或是发送一些数据到其他地方，如 MQ、Handler 等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rabbitmq | 06 - RPC</title>
      <link>https://ijayer.github.io/post/tech/mq/20190614-rabbitmq-rpc/</link>
      <pubDate>Sat, 22 Jun 2019 22:56:56 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190614-rabbitmq-rpc/</guid>
      <description>这一节使用 RabbitMQ 构建 RPC 系统：包含一个客户端和一个可扩展的服务端，服务端是一个虚拟的 RPC Service，用来返回 Fibonacci 数 有关 RPC 的说明： 尽管 RPC 在计算过程中</description>
    </item>
    
    <item>
      <title>Rabbitmq | 05 - Topics</title>
      <link>https://ijayer.github.io/post/tech/mq/20190613-rabbitmq-topics/</link>
      <pubDate>Thu, 13 Jun 2019 22:48:56 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190613-rabbitmq-topics/</guid>
      <description>前面，分别使用了 fanout 和 direct 类型实现了简易的日志生产、路由和消费，虽然 direct 可以按照 Binding_Key 绑定关系实现日志过滤，但其仍有局限性，即不能基于多个标准进行消息</description>
    </item>
    
    <item>
      <title>Rabbitmq | 04 - Routing</title>
      <link>https://ijayer.github.io/post/tech/mq/20190602-rabbitmq-routing/</link>
      <pubDate>Sun, 02 Jun 2019 17:05:35 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190602-rabbitmq-routing/</guid>
      <description>这一小节继续前面的内容，给日志系统添加新特性：只订阅一部分消息。 Bindings 上一小节我们创建了 Exchange 和 Queue 的一个绑定，代码描述如下： 1 2 3 4 5 6 7 err = ch.QueueBind( q.Name, &amp;#34;&amp;#34;,</description>
    </item>
    
    <item>
      <title>Rabbitmq | 03 - Publish/Subscribe</title>
      <link>https://ijayer.github.io/post/tech/mq/20190519-rabbitmq-publish.subscribe/</link>
      <pubDate>Sun, 19 May 2019 17:28:12 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190519-rabbitmq-publish.subscribe/</guid>
      <description>Publish/Subscribe: Send messages to many consumers at once. 这一小节，通过实现一个日志系统来学习 RabbitMQ p/b 的简单用法：该日志系统由2个程序构成，第一个用来发送日志消息，第二个则用来接收并将其</description>
    </item>
    
    <item>
      <title>Rabbitmq | 02 - Work Queues</title>
      <link>https://ijayer.github.io/post/tech/mq/20190401-rabbitmq-work-queues/</link>
      <pubDate>Mon, 01 Apr 2019 11:13:00 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190401-rabbitmq-work-queues/</guid>
      <description>实现一个用来在多个 Workers 之间分发 耗时任务 的工作队列。 那么为什么会出现工作队列呢？可以和上节的 Simple 队列做简单对比： Simple 队列是一一对应的，而且我们在实际</description>
    </item>
    
    <item>
      <title>Rabbitmq | 01 - Hello World</title>
      <link>https://ijayer.github.io/post/tech/mq/20190328-rabbitmq-hello-world/</link>
      <pubDate>Fri, 29 Mar 2019 16:05:39 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/mq/20190328-rabbitmq-hello-world/</guid>
      <description>RabbitMQ 是一个开源的、使用最广的消息队列。 Erlang 开发，对高并发、路由、负载均衡、数据持久化有很好的支持。 支持的协议：AMQP，XMPP, SMTP, STOMP 支持集群部</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 07 - go语句以及执行规则（下）</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-07/</link>
      <pubDate>Sun, 13 Jan 2019 11:57:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-07/</guid>
      <description>Q1：用什么手段可以对 goroutine 的启用数量加以限制 ? Q2：怎样才能让主 goroutine 等待其他 goroutine ? Q3：怎样让我们启用的多个 goroutine 按照既定的顺序执行 ? 专栏：17 | go 语</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 06 - go语句以及执行规则（上）</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-06/</link>
      <pubDate>Sat, 12 Jan 2019 14:51:10 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-06/</guid>
      <description>进程、线程(系统级) goroutine(用户级) 调度器 专栏：16 | go 语句及其执行规则（上） — Malcolm Lightbody @mlightbody 前导内容：进程与线程 进程：描述的就是程序的</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 05 - 使用函数的正确姿势</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-05/</link>
      <pubDate>Mon, 07 Jan 2019 11:37:08 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-05/</guid>
      <description>函数类型、函数签名 高阶函数 闭包 函数传参 专栏：12 | 使用函数的正确姿势 — zher，杭州图书馆 2019-01-06 日 16 时许 函数是一等公民 函数：一等的(first-</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 04 - 程序性能分析基础</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-04/</link>
      <pubDate>Tue, 18 Dec 2018 21:45:30 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-04/</guid>
      <description>性能分析，有哪些工具可以用？ 概要文件的采样、收集和输出是怎样的，包括怎样启动和停止采样、怎样设定采样频率以及怎样控制输出内容的格式和详细程度</description>
    </item>
    
    <item>
      <title>Golang | 语言机制之数据和语法的设计哲学</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-04-%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link>
      <pubDate>Sun, 16 Dec 2018 17:25:00 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-04-%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid>
      <description>本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃&amp;gt; 逸分析和值/指针传递。这是第二篇，主</description>
    </item>
    
    <item>
      <title>Golang | 语言机制之内存剖析</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-03-%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90/</link>
      <pubDate>Fri, 14 Dec 2018 10:24:56 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-03-%E5%86%85%E5%AD%98%E5%89%96%E6%9E%90/</guid>
      <description>本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃&amp;gt; 逸分析和值/指针传递。这是第二篇，主</description>
    </item>
    
    <item>
      <title>Golang | 语言机制之逃逸分析</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-02-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 12 Dec 2018 15:24:52 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-02-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃&amp;gt; 逸分析和值/指针传递。这是第二篇，主</description>
    </item>
    
    <item>
      <title>Golang | 语言机制之栈和指针</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-01-%E6%A0%88%E5%92%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 11 Dec 2018 17:24:40 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181212-go%E8%AF%AD%E8%A8%80%E6%9C%BA%E5%88%B6-01-%E6%A0%88%E5%92%8C%E6%8C%87%E9%92%88/</guid>
      <description>本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃&amp;gt; 逸分析和值/指针传递。这是第二篇，主</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 03 - Container 包中的那些容器</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-03/</link>
      <pubDate>Mon, 03 Dec 2018 14:02:03 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-03/</guid>
      <description>Six interesting containers in Golang From pkg/container container/list container/ring container/heap Built in map slice Channels as quenues Container Container — 容器数据类型：该包实现了三个复杂的数据结构：堆、链表、环 List Go 语言标准库的 container/list 代码包提供的对 链表 的实现。</description>
    </item>
    
    <item>
      <title>[转] Golang | Slice 深入理解</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181121-slice-src-reading/</link>
      <pubDate>Wed, 21 Nov 2018 14:06:08 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181121-slice-src-reading/</guid>
      <description>转自：深入解析 Go 中 Slice 底层实现 深入解析 Go 中 Slice 底层实现 切片是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。切片的设计想法是由动态数</description>
    </item>
    
    <item>
      <title>Golang | Slice Deep Learning</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20181117-slice-deep-learning/</link>
      <pubDate>Sat, 17 Nov 2018 14:00:24 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20181117-slice-deep-learning/</guid>
      <description>Go Blog: Go slice internals 学习笔记 Slice internals A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment). 一个切片就是一个数组片段的描述符。它(切片)包含了一个指</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 02-数组与切片</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-02/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-02/</guid>
      <description>通过上 小结 学习主要加深了对：常用源码文件(命令、库、测试)写法、程序实体(常量、变量、结构体、函数、接口, 尤其是变量)以及相关的各种概念和编</description>
    </item>
    
    <item>
      <title>Golang | gRPC学习笔记-05 | 编码实践</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180910-grpc-05-practice/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180910-grpc-05-practice/</guid>
      <description>学习完了理论知识，开始写点 Demo 体验一番吧！ Sohoo！😋 Statement: 文章转载自 大桥下的蜗牛 =&amp;gt; 视频笔记：gRPC 从学习到生产 - Alan Shreve。 原文(英)：</description>
    </item>
    
    <item>
      <title>Golang | gRPC学习笔记-04 | 什么是 Protocol Buffers？</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180907-grpc-04-what-is-protocol-buffers/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180907-grpc-04-what-is-protocol-buffers/</guid>
      <description>上一小节，简单熟悉了一下 gRPC，接下来继续学习 Protocol Buffers 的相关知识： 什么是 Protocol Buffers ? .proto 文件怎么写？ -&amp;gt; 语言规范 .proto 文件写好了怎么用？ 本指南描述了怎样使用</description>
    </item>
    
    <item>
      <title>Golang | gRPC学习笔记-03 | 什么是 gRPC？</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180906-grpc-03-what-is-grpc/</link>
      <pubDate>Thu, 06 Sep 2018 09:12:12 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180906-grpc-03-what-is-grpc/</guid>
      <description>上一小节，简单熟悉了一下 RPC，接下来继续学习 gRPC 的基础概念： 什么是 gRPC ? gRPC 的关键概念有哪些 ? 在 gRPC 中，如何去定义一个服务 ？ gRPC 服务类型有哪几种？ 一</description>
    </item>
    
    <item>
      <title>Golang | gRPC学习笔记-02 | 什么是 RPC？</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180905-grpc-02-what-is-rpc/</link>
      <pubDate>Thu, 06 Sep 2018 08:12:12 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180905-grpc-02-what-is-rpc/</guid>
      <description>上一小节，简单熟悉了一下基于 gRPC 的 Hello World Demo 程序，接下来学习 gRPC 的相关概念知识，先来看 RPC: 什么是 RPC ? RPC 的核心概念有哪些？ RPC 是调用流程是怎么样的？ Statement: 文中</description>
    </item>
    
    <item>
      <title>Golang | gRPC学习笔记-01 | Hello World Demo</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180904-grpc-01-helloworld/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180904-grpc-01-helloworld/</guid>
      <description>Ok, 先来安装 gRPC 的开发环境，并且实践一下 Hello World 程序吧！ 1. 开发环境 ENV: go version go1.11 windows/amd64 IDE: goland 使用 gRPC 需要安装以下开发环境 Install gRPC (RPC框架) Install Protocol Buffers v3 (Google推</description>
    </item>
    
    <item>
      <title>Golang | gRPC 学习笔记集</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180904-grpc-00/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180904-grpc-00/</guid>
      <description>🙂 So, 开始学习 gRPC 啦！！！ 学习笔记，内容包括： Note1: gRPC | Hello Wrold Note2: gRPC基础概念 | 什么是 RPC? Note3: gRPC基础概念 | 什么是 gRPC? Note4: gRPC基础概念 | 什么是 Protocol Buffers? See</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 01-基础概念补漏</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-01/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-01/</guid>
      <description>这一节，主要跟着专栏第一章补漏一些必备的基础概念，内容概览： Go 中的源码文件分类 关于命令源码文件、库源码文件你漏掉了那些知识点？ 程序实体那些事</description>
    </item>
    
    <item>
      <title>『Go核心36讲』| 学习笔记集</title>
      <link>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-00/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/tutorial-go36-00/</guid>
      <description>《Go语言核心36讲》 是郝林老师发布的一则专栏教程(付费)，以音频+文稿的方式系统的讲述了 Go 的知识。 我自己使用 Go 已经有两年时间了(从毕业到现</description>
    </item>
    
    <item>
      <title>Golang | 依赖管理-02：Go Modules 使用笔记</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180828-feature-go-modules-02/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180828-feature-go-modules-02/</guid>
      <description>Go1.11 新特性 — 依赖管理工具：Go Modules 使用过程学习笔记，内容包括: 如何在 新 的项目上使用 go modules 如何在 旧 的项目中引入 go modules Statement: 文中部分内容参考自网络博客(地址</description>
    </item>
    
    <item>
      <title>Golang | 依赖管理-01：Go Modules 初步了解和学习</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180828-feature-go-modules-01/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180828-feature-go-modules-01/</guid>
      <description>Go1.11 新特性 — 依赖管理工具：Go Modules 初步学习和使用笔记，内容包括: 简单了解下 Go Module 以及一些新概念 简单了解下 go mod 命令 1. Go Module Go1.11 添加了对版本化模块的初步支</description>
    </item>
    
    <item>
      <title>Golang | 理解 Golang 的 nil (转)</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180822-advanced-%E7%90%86%E8%A7%A3golang%E7%9A%84nil/</link>
      <pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180822-advanced-%E7%90%86%E8%A7%A3golang%E7%9A%84nil/</guid>
      <description>理解 nil nil 是什么？ nil 在 Go 中又是什么？ nil 意味着什么？ nil 有用吗？ 我们常常会把 nil 拼写成 null, 学过 C 的同学肯定听过这个 null 符号，甚至某些让人痛恨的同学还故意</description>
    </item>
    
    <item>
      <title>Golang | Pits =&gt; Concurrent access map</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180718-concurrent-access-map-pits/</link>
      <pubDate>Wed, 18 Jul 2018 14:09:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180718-concurrent-access-map-pits/</guid>
      <description>Issue: 为什么 map 并发不安全，读也不安全吗？ 代码测试 单个 goroutine 读写 map 的 Demo: 结论：正常 多个 goroutine 只写 的 Demo： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description>
    </item>
    
    <item>
      <title>Golang | Step-by-step guide to concurrency 学习笔记</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180701-tutorial_step-by-step-guide-to-concurrency/</link>
      <pubDate>Sun, 01 Jul 2018 14:09:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180701-tutorial_step-by-step-guide-to-concurrency/</guid>
      <description>原文：Step-by-step guide to concurrency 参考：Go并发编程基础（译） 内容涵盖： 运行期并发线程(goroutines) 基本的同步技术(通道和锁) G</description>
    </item>
    
    <item>
      <title>Golang | cmd - go cgo</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180629-go_cmd_03_cgo/</link>
      <pubDate>Fri, 29 Jun 2018 14:09:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180629-go_cmd_03_cgo/</guid>
      <description>Cgo 支持创建调用 C 代码的 Go 包 通过 go 命令使用 cgo 为了使用 cgo, 你需要在普通的 Go 代码中导入一个 伪包 &amp;quot;C&amp;quot;。这样 Go 代码就可以引用一些 C</description>
    </item>
    
    <item>
      <title>Golang | cmd - go install | run | clean | env | get</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180627-go_cmd_02_install_run_clean_env_get/</link>
      <pubDate>Wed, 27 Jun 2018 14:09:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180627-go_cmd_02_install_run_clean_env_get/</guid>
      <description>go install go run go clean go env go get 目录 go install go run go clean go env go get See Also go install 完成两步操作： 第一步是生成结果文件(可执行文件或.a文件) 第二步是把编译好的结果文件移到</description>
    </item>
    
    <item>
      <title>Golang | cmd - go build 构建 C 的静态 &#43; 动态链接库、Go 的动态链接库</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180625-go_cmd_01_3_go-build_c-archive_c-shared_go-shared/</link>
      <pubDate>Mon, 25 Jun 2018 14:09:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180625-go_cmd_01_3_go-build_c-archive_c-shared_go-shared/</guid>
      <description>Go 中如何构建 C 的静态链接库 Go 中如何构建 C 的动态链接库 Go 中如何构建 Go 的动态链接库 目录 c-archive c-shared 为什么会需要动态链接库 shared See Also c-archive 这里构建的是供 C 程序调用</description>
    </item>
    
    <item>
      <title>Golang | cmd - go build 构建模式</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180624-go_cmd_01_2_go-build-mode/</link>
      <pubDate>Sun, 24 Jun 2018 14:07:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180624-go_cmd_01_2_go-build-mode/</guid>
      <description>build modes The &amp;lsquo;go build&amp;rsquo; and &amp;lsquo;go install&amp;rsquo; commands take a -buildmode argument which indicates which kind of object file is to be built. Currently supported values are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -buildmode=archive Build the listed</description>
    </item>
    
    <item>
      <title>Golang | cmd - go build 构建约束</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180623-go_cmd_01_1_go-build-constraint/</link>
      <pubDate>Sat, 23 Jun 2018 14:04:26 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180623-go_cmd_01_1_go-build-constraint/</guid>
      <description>Build Constraints(约束) Build -tags A build constraint, also known as a build tag, is a line comment that begins 1 // +build that lists the conditions under which a file should be included in the package. Constraints may appear in any kind of source file (not just Go), but they must appear near the top of</description>
    </item>
    
    <item>
      <title>Golang | Performance Optimization =&gt; go tarch 学习笔记</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180620-performance-optimization-04-go-torch/</link>
      <pubDate>Tue, 19 Jun 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180620-performance-optimization-04-go-torch/</guid>
      <description>go tarch（火焰图）学习笔记 火焰图(Flame Graph) 火焰图 也是性能分析的利器。最初是由 Netflix 的 Brendan Gregg 发明并推广的。 图片来自：blog.lab99.o</description>
    </item>
    
    <item>
      <title>Golang | Performance Optimization =&gt; 优化建议</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180619-performance-optimization-05-experience/</link>
      <pubDate>Tue, 19 Jun 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180619-performance-optimization-05-experience/</guid>
      <description>转自：Debugging performance issues in Go programs 1. 将多个小对象合并成一个大对象 2. 减少不必要的指针简介引用，多使用 copy 引用 例如使用 bytes.Buffer 代替 *bytes.Buffer, 因为使用指针时会分配</description>
    </item>
    
    <item>
      <title>Golang | Performance Optimization =&gt; pprof practice</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180615-performance-optimization-03-pprof-practice/</link>
      <pubDate>Fri, 15 Jun 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180615-performance-optimization-03-pprof-practice/</guid>
      <description>pprof 小练习 实践练习项目：Golang profiling and optimizing 注册自定义的 pprof 接口(基于httprouter) 注册接口函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 使用自定义</description>
    </item>
    
    <item>
      <title>Golang | Stdlib - runtime</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180610-stdlib-runtime/</link>
      <pubDate>Sun, 10 Jun 2018 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180610-stdlib-runtime/</guid>
      <description>了解 runtime 包中的的环境变量 了解 runtime 包中的基本函数及使用 目录 1. 概述 2. 环境变量 2.1. GOGC 2.2. GODEBUG 2.3. GOMAXPROCS 2.4. GOTRACEBACK 2.5. GOARCH、GOOS、GOPATH、GOROOT 3. 基</description>
    </item>
    
    <item>
      <title>Golang | Performance Optimization =&gt; pprof</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180606-performance-optimization-02-pprof-usage/</link>
      <pubDate>Wed, 06 Jun 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180606-performance-optimization-02-pprof-usage/</guid>
      <description>go tool pprof 用法 cpu、goroutine、heap 分析方法 pprof Pprof 是一款可视化的性能分析工具，源自 Google Performance Tools 工具集。用于确定程序运行过程中CPU和内存的</description>
    </item>
    
    <item>
      <title>Golang | 程序性能优化学习笔记</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180605-performance-optimization-01-introduction/</link>
      <pubDate>Tue, 05 Jun 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180605-performance-optimization-01-introduction/</guid>
      <description>程序优化有哪些方式和步骤？ 可供选择的调优工具有哪些？ 调优之前 如何做Go的性能优化？ 调优方式 要监控程序性能，有下面几种方式： Timers: 计时器，用于基准</description>
    </item>
    
    <item>
      <title>Golang | 关于 for range 的一些细节</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180328-%E5%85%B3%E4%BA%8E_for-range_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</link>
      <pubDate>Wed, 28 Mar 2018 13:48:02 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180328-%E5%85%B3%E4%BA%8E_for-range_%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</guid>
      <description>for range 的迭代变量会被重用 range expression 的副本参与 iteration 1. iteration variable 重用 for range 的 idiomatic(惯用)使用方式是使用 short variable declaration(:=) 形式在 for expression 中声明 iteration variable，但需</description>
    </item>
    
    <item>
      <title>Golang | net/http =&gt; Customize Handler、ServeMux、Middleware</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180320_net-http_02_customize-handler&#43;servemux&#43;middleware/</link>
      <pubDate>Tue, 20 Mar 2018 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180320_net-http_02_customize-handler&#43;servemux&#43;middleware/</guid>
      <description>怎么定义 Handler？ 怎么定义 Server？ 怎么定义 Middleware？ 如何用？ 目录 自定义 Handler 自定义 Server 中间件 Middleware See Also 自定义 Handler 标准库http提</description>
    </item>
    
    <item>
      <title>Golang | net/http =&gt; server.go 源码阅读</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180316_net-http_01_reading-server.go/</link>
      <pubDate>Fri, 16 Mar 2018 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180316_net-http_01_reading-server.go/</guid>
      <description>src/net/http/server.go ResponseWriter ? Handler ? ServerMux ? Server ? 目录 HTTP HTTP处理流程 几个重要接口或结构 文中的几个重要约定 Handler ServeMux ServeMux 提供的方法 Server 创建 HTTP 服务 注册路由 服务监听 处理请求 总结 http</description>
    </item>
    
    <item>
      <title>Golang | 定时任务</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180307-lib-cron-learn-note/</link>
      <pubDate>Wed, 07 Mar 2018 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180307-lib-cron-learn-note/</guid>
      <description>Cron go get github.com/robfig/cron cron(定时任务): 按照约定的时间，定时的执行特定的任务（job），cron 表达式表达了这种约定。 cron表达式格式 格式1 cron 表达式</description>
    </item>
    
    <item>
      <title>Golang | mgo - Rich MongoDB Driver for Go [译]</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180127-lib-mgo/</link>
      <pubDate>Sat, 27 Jan 2018 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180127-lib-mgo/</guid>
      <description>译：Rich MongoDB Driver for Go 目录 1. Highlights(强调) 1.1. Cluster discovery and communication(集群发现和通信) 1.2. Failover management(故障转移</description>
    </item>
    
    <item>
      <title>Golang | 单元测试</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20171113-go-unit-test/</link>
      <pubDate>Mon, 13 Nov 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20171113-go-unit-test/</guid>
      <description>单元测试 单元测试基础 Go单元测试采用内置的测试框架，通过引入 testing 包以及 go test 命令来提供测试功能 testing 包专门用来进行自动化测试，日志和错误报告，且包含</description>
    </item>
    
    <item>
      <title>Golang | CGO =&gt; 基础 </title>
      <link>https://ijayer.github.io/post/tech/code/golang/20171023-cgo-note/</link>
      <pubDate>Mon, 23 Oct 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20171023-cgo-note/</guid>
      <description>《深入 CGO 编程》 学习笔记 最简单的CGO程序 hello cgo 1 2 3 4 5 import &amp;#34;C&amp;#34; func main() { println(&amp;#34;hello cgo&amp;#34;) } 代码通过 import &amp;quot;C&amp;quot; 语句启用 CGO 特性，主函数只是通过 Go 内置的 println 函数输出字符串，其</description>
    </item>
    
    <item>
      <title>Golang | 函数</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20171013-go-func/</link>
      <pubDate>Fri, 13 Oct 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20171013-go-func/</guid>
      <description>函数 函数签名：函数参数列表 + 函数返回值 func(i int, s string) string 签名为：func(int, string) string 多返回值 标准库中的函数通常返回2个值，一个是期望得到的返回值，</description>
    </item>
    
    <item>
      <title>Golang | 模板</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20171010-go-template/</link>
      <pubDate>Tue, 10 Oct 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20171010-go-template/</guid>
      <description>什么是模板 Go中模板处理通过包: text/template 和 html/template 完成 一个模板就是一个字符串或一个文件，里面包含了一个或多个双花括号 {{}} 包含的对象 Go中模板解析 Go中模板</description>
    </item>
    
    <item>
      <title>Golang | SFTP</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20170808-lib-sftp/</link>
      <pubDate>Tue, 08 Aug 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20170808-lib-sftp/</guid>
      <description>SFTP 用于远程传输文件；基于SSH协议设计，所以传输文件前首先要建立SSH连接，在 Golang | SSH Note 有关于SSH包的使用笔记，同时，使用SSH也可以完成远</description>
    </item>
    
    <item>
      <title>Golang | SSH</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20170807-lib-ssh/</link>
      <pubDate>Mon, 07 Aug 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20170807-lib-ssh/</guid>
      <description>SSH 简介 https://godoc.org/golang.org/x/crypto/ssh SSH 客户端 工作流程 Linux SSH Work Flow: execute: ssh root@host:ip input: pwd hosted remote shell: execute command 同理，通过 Golang 的 SSH 包提供的函数也要实现上述流程： Input command by keyboard Obtain user&amp;rsquo;s input from os.Stdin Establish a ssh connect Send data|cmd by ssh 获取标准</description>
    </item>
    
    <item>
      <title>Golang | Stdlib: Flag 学习笔记</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20180912-stdlib-flag/</link>
      <pubDate>Tue, 25 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20180912-stdlib-flag/</guid>
      <description>flag 包学习笔记概要： 如何定义命令行参数，即 flags ？ flags 解析规则及语法格式 ？ flag 包有哪些重要的变量、函数以及类型 ？ 如何绑定用户自定义的数据类型作为参数值</description>
    </item>
    
    <item>
      <title>Golang | 同步与锁</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20170608-go-sync-and-mutex/</link>
      <pubDate>Thu, 08 Jun 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20170608-go-sync-and-mutex/</guid>
      <description>Mutex 互斥锁是传统的并发程序对共享资源进行访问控制的主要手段。 sync.Mutex 是一个互斥锁，其作用是守护在临界区入口来保证同一时间只有一个线程进入临界区。其在</description>
    </item>
    
    <item>
      <title>Golang | 闭包</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20170603-go-closure/</link>
      <pubDate>Sat, 03 Jun 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20170603-go-closure/</guid>
      <description>闭包概念 闭包字面定义：闭包是由函数及相关引用环境组合而形成的实体。(即：闭包=函数+引用环境) 闭包的理解：闭包是个函数，而他记住了周期性发生</description>
    </item>
    
    <item>
      <title>Golang | Context 基础</title>
      <link>https://ijayer.github.io/post/tech/code/golang/20170307-go-context-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 07 Mar 2017 16:07:43 +0800</pubDate>
      
      <guid>https://ijayer.github.io/post/tech/code/golang/20170307-go-context-%E5%9F%BA%E7%A1%80/</guid>
      <description>简介 Context： 上下文，上下层间传递的内容，通常理解为一个程序单元(goroutine)的运行状态、快照或者现场。主要应用在由一个请求衍</description>
    </item>
    
  </channel>
</rss>